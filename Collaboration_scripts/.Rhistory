step   = "plot_heatmap",
msg    = "`annotation_palette` must be either 'discrete' or 'continuous'.")
}
# Validate `border_color`
if (!is.null(border_color) && !is.na(border_color)) {
if (!is.character(border_color) || length(border_color) != 1) {
log_error(sample = "",
step   = "plot_heatmap",
msg    = "`border_color` must be a single character color or NA.")
}
if (!border_color %in% colors()) {
log_warn(sample = "",
step   = "plot_heatmap",
msg    = glue::glue("`border_color` '{border_color}' is not a standard R color."))
}
}
# ðŸ›¡ Metadata Validation
# Helper function for checking single-character metadata columns
validate_single_column <- function(col_value, col_name, metadata_df = NULL) {
if (!gtools::invalid(col_value)) {
if (!is.character(col_value) || length(col_value) != 1) {
log_error(sample = "",
step   = "plot_heatmap",
msg    = glue::glue("'{col_name}' must be a single character value."))
}
if (!is.null(metadata_df) && !(col_value %in% colnames(metadata_df))) {
log_error(sample = "",
step   = "plot_heatmap",
msg    = glue::glue("'{col_name}' '{col_value}' must be a column in the metadata dataframe."))
}
}
}
# Helper function for checking multiple-column metadata annotations
validate_multi_column <- function(cols, col_name, metadata_df) {
if (!gtools::invalid(cols)) {
missing_cols <- setdiff(cols, colnames(metadata_df))
if (length(missing_cols) > 0) {
log_error(sample = "",
step  = "plot_heatmap",
msg   = glue::glue("{col_name} missing in metadata: {paste(missing_cols, collapse=', ')}"))
}
}
}
# Validate col_annotations, col_gap_by, col_cluster_by
requires_col_metadata <- (!gtools::invalid(col_annotations) ||
!gtools::invalid(col_gap_by) ||
(!col_cluster_by %in% c("all", "alphabetical")))
if (requires_col_metadata && is.null(metadata_col)) {
log_error(sample = "",
step   = "plot_heatmap",
msg    = "col_annotations, col_gap_by, or col_cluster_by require metadata_col, but it is NULL.")
}
if (!is.null(metadata_col)) {
validate_single_column(col_cluster_by, "col_cluster_by")
validate_single_column(col_gap_by, "col_gap_by", metadata_col)
validate_multi_column(col_annotations, "col_annotations", metadata_col)
}
# Validate row_annotations, row_gap_by, row_cluster_by
requires_row_metadata <- (!gtools::invalid(row_annotations) ||
!gtools::invalid(row_gap_by) ||
(!row_cluster_by %in% c("all", "alphabetical")))
if (requires_row_metadata && is.null(metadata_row)) {
log_error(sample = "",
step   = "plot_heatmap",
msg    = "row_annotations, row_gap_by, or row_cluster_by require metadata_row, but it is NULL.")
}
if (!is.null(metadata_row)) {
validate_single_column(row_cluster_by, "row_cluster_by")
validate_single_column(row_gap_by, "row_gap_by", metadata_row)
validate_multi_column(row_annotations, "row_annotations", metadata_row)
}
# ---- ðŸ§ª Prepare Matrix & Normalization ----
# Convert column names to valid R names
colnames(expr_mat) <- make.names(colnames(expr_mat))
# # Retain ONLY samples in metadata for accurate zero count calculations
# if (!is.null(metadata_col)){
#   expr_mat <- expr_mat[, intersect(colnames(expr_mat), rownames(metadata_col)), drop = FALSE]
# }
# Remove rows with NA gene names
na_rows <- is.na(rownames(expr_mat))
expr_mat <- expr_mat[!na_rows, , drop = FALSE]
log_info(sample = "",
step   = "plot_heatmap",
msg    = glue::glue("Removed {sum(na_rows)} rows with missing gene names."))
# Replace missing counts with 0
expr_mat[is.na(expr_mat)] <- 0
# Convert all columns to numeric safely
expr_mat <- matrix(as.numeric(as.matrix(expr_mat)),
nrow = nrow(expr_mat),
ncol = ncol(expr_mat),
dimnames = dimnames(expr_mat))
if (any(is.na(expr_mat))) {
log_error(sample = "",
step   = "plot_heatmap",
msg    = "`expr_mat` contains non-numeric values that could not be converted.")
}
# Remove genes with zero counts across all samples
zero_genes   <- rownames(expr_mat)[which(rowSums(expr_mat) == 0)]
expr_mat <- expr_mat[rowSums(expr_mat) != 0, , drop = FALSE]
log_info(sample = "",
step   = "plot_heatmap",
msg    = glue::glue("Removed {length(zero_genes)} genes with zero counts across all samples."))
# Remove samples with zero total reads
zero_samples <- colnames(expr_mat)[which(colSums(expr_mat) == 0)]
expr_mat <- expr_mat[, colSums(expr_mat) != 0, drop = FALSE]
log_info(sample = "",
step   = "plot_heatmap",
msg    = glue::glue("Removed {length(zero_samples)} samples with zero total counts."))
# Handle duplicate gene symbols if any
if (any(duplicated(rownames(expr_mat)))) {
expr_mat <- expr_mat %>%
tibble::rownames_to_column("SYMBOL") %>%
dplyr::mutate(total_expr = rowSums(across(-SYMBOL))) %>%  # Sum across all samples
dplyr::group_by(SYMBOL) %>%
dplyr::slice_max(order_by = total_expr, n = 1, with_ties = FALSE) %>% # Keep row with highest total expression
dplyr::ungroup() %>%
tibble::column_to_rownames("SYMBOL") %>%
dplyr::select(-total_expr)                                # Drop the temporary column
}
# Convert rownames and colnames to valid R names
rownames(expr_mat) <- make.names(rownames(expr_mat))
colnames(expr_mat) <- make.names(colnames(expr_mat))
# Check for high dynamic range to trigger log transform
quantiles <- stats::quantile(x = as.vector(as.matrix(expr_mat)), probs = c(0, 0.01, 0.99, 1), na.rm = TRUE)
huge_range <- (quantiles[4] - quantiles[1]) > 100   # Range of values greater than 100
only_pos <- quantiles[1] >= 0                       # Min value greater than 0
if ((huge_range & only_pos) | force_log){
expr_mat <- log2(1 + expr_mat)
}
# Perform Z-score scaling (across rows i.e. genes)
expr_mat_scaled <- expr_mat %>% t() %>% scale() %>% t()
expr_mat_scaled[is.na(expr_mat_scaled)] <- 0
# ---- ðŸ·ï¸ Prepare Annotations & Colors ----
# Column (Sample) Annotation
col_annotation <- if (!is.null(metadata_col)) {
metadata_col %>%
dplyr::select(Sample_ID, all_of(col_annotations)) %>%
dplyr::mutate(Sample_ID = make.names(Sample_ID)) %>%
dplyr::filter(Sample_ID %in% colnames(expr_mat)) %>%
tibble::remove_rownames() %>%
tibble::column_to_rownames("Sample_ID") %>%
as.data.frame() %>%
mutate(across(where(is.factor), as.character))
} else NULL
# Row (Gene) Annotation
row_annotation <- if (!is.null(metadata_row)) {
metadata_row %>%
dplyr::select(SYMBOL, all_of(row_annotations)) %>%
dplyr::mutate(SYMBOL = make.names(SYMBOL)) %>%
dplyr::filter(SYMBOL %in% rownames(expr_mat)) %>%
tibble::remove_rownames() %>%
tibble::column_to_rownames("SYMBOL") %>%
as.data.frame() %>%
mutate(across(where(is.factor), as.character))
} else NULL
# Generate Annotation Palette
# This is an example of how ann_colors should be specified
ann_colors <- list(CellType = c(CT1 = "#1B9E77", CT2 = "#D95F02"),
GeneClass = c(Path1 = "#7570B3", Path2 = "#E7298A", Path3 = "#66A61E"))
ann_colors <- list()
base_colors <- if (exists("custom_palette")) {
custom_palette
} else {
log_error(sample = "",
step   = "plot_heatmap",
msg    = "`custom_palette` not defined. Needed for annotation of heatmaps.")
}
col_list <- base::lapply(X = as.list(col_annotation), FUN = function(x) { as.character(x) %>% unique})
row_list <- base::lapply(X = as.list(row_annotation), FUN = function(x) { as.character(x) %>% unique})
ann_list <- c(row_list, col_list)
color_index <- 1
for (i in seq_along(ann_list)) {  # Iterate through each annotation variable (Eg: CellType)
levels <- sort(ann_list[[i]])   # Get levels within each annotation variable (Eg: CT1, CT2)
n_levels <- length(levels)      # Get number of levels within each annotation variable
palette_colors <- if (annotation_palette == "discrete" | n_levels == 1){
base_colors[color_index:(color_index + n_levels - 1)]
} else if (annotation_palette == "continuous"){
alphas <- seq(1 / n_levels, 1, length.out = n_levels)
base::sapply(X = alphas,
FUN = function(x) { colorspace::adjust_transparency(col = base_colors[color_index], alpha = x) })
}
names(palette_colors) <- levels                   # Name each color with levels
ann_colors <- c(ann_colors, list(palette_colors)) # Append named color palette
names(ann_colors)[i] <- names(ann_list)[i]        # Name the color palette with corresponding annotation variable name
color_index <- color_index + n_levels             # Move to next color
}
# ---- ðŸŽ¨ Heatmap Palette & Breaks ----
# Define number of Color Breaks
n_breaks <- 100
# Define Color Palette for Heatmap
heatmap_palette <- if (heatmap_palette == "vrds") {
viridis::viridis(n_breaks)
} else if (heatmap_palette == "rdbu") {
colorRampPalette(rev(RColorBrewer::brewer.pal(n = 11, name = "RdBu")))(n_breaks)
} else {
log_error(sample = "",
step   = "plot_heatmap",
msg    = "`heatmap_palette` '{heatmap_palette}' must be either 'vrds' or 'rdbu'.")
}
# Handle min and max thresholds with soft clamping
expr_mat_min <- min(expr_mat_scaled, na.rm = TRUE)
expr_mat_max <- max(expr_mat_scaled, na.rm = TRUE)
expr_mat_min <- dplyr::case_when(expr_mat_min >= 0 ~ 0,
expr_mat_min <= -3 ~ -3,
TRUE ~ expr_mat_min)
expr_mat_max <- dplyr::case_when(expr_mat_max <= 0 ~ 0,
expr_mat_max >= 3 ~ 3,
TRUE ~ expr_mat_max)
# Custom breaks to ensure zero-centering
if (expr_mat_max == 0) {
breaks <- seq(from = floor(expr_mat_min), to = 0, length.out = n_breaks)
} else if (expr_mat_min == 0) {
breaks <- seq(from = 0, to = ceiling(expr_mat_max), length.out = n_breaks)
} else {
breaks <- c(seq(from = floor(expr_mat_min), to = 0, length.out = n_breaks / 2),
seq(from = expr_mat_max / n_breaks, to = ceiling(expr_mat_max), length.out = n_breaks / 2))
}
# ---- ðŸ Gaps Logic ----
# Define gaps in columns
gaps_col <- NULL
if (!gtools::invalid(col_gap_by)) {
if (col_gap_by %in% colnames(col_annotation)) {
gaps_col <- col_annotation %>%
dplyr::count(.data[[col_gap_by]]) %>%
dplyr::mutate(n = cumsum(n)) %>%
dplyr::pull(n) %>%
.[. < ncol(expr_mat_scaled)]
} else {
log_warn(sample = "",
step   = "plot_heatmap",
msg    = glue::glue("col_gap_by '{col_gap_by}' is absent in metadata_col."))
}
}
# Define gaps in rows
gaps_row <- NULL
if (!gtools::invalid(row_gap_by)) {
if (row_gap_by %in% colnames(row_annotation)) {
gaps_row <- row_annotation %>%
dplyr::count(.data[[row_gap_by]]) %>%
dplyr::mutate(n = cumsum(n)) %>%
dplyr::pull(n) %>%
.[. < nrow(expr_mat_scaled)]
} else {
log_warn(sample = "",
step   = "plot_heatmap",
msg    = glue::glue("row_gap_by '{row_gap_by}' is absent in metadata_row."))
}
}
# ---- ðŸ“Š Clustering & Ordering ----
# Clustering guideline:
#   # - Use Ward.D2 linkage only with Euclidean distances (e.g., after z-scoring rows),
#   #   as Ward assumes Euclidean geometry to minimize within-cluster variance.
#   # - Use average or complete linkage when using correlation-based distances (1 - cor(x)),
#   #   since correlation distances are not strictly Euclidean and Ward may produce unintuitive results.
# Logical ordering for columns (Samples)
if (col_cluster_by %in% colnames(col_annotation)) {
# Initialize column order
col_order <- c()
# Identify all groups
col_vars <- col_annotation %>%
dplyr::pull(col_cluster_by) %>%
unique() %>%
sort()  # While calculating gaps_col, we use count() which sorts
# alphabetically. So, WE MUST sort col_vars to match gaps_col
# Iterate over each group
for (col_var in col_vars){
# Get samples belonging to this group
samples <- col_annotation %>%
tibble::rownames_to_column("Sample_ID") %>%
dplyr::filter(.data[[col_cluster_by]] == col_var) %>%
dplyr::pull(Sample_ID) %>%
base::intersect(., colnames(expr_mat_scaled))
if (length(samples) > 1){
# Hierarchical clustering within cluster
temp_mat  <- expr_mat_scaled[, samples, drop = FALSE]
col_dist  <- stats::dist(x = t(temp_mat), method = "euclidean")
col_clust <- stats::hclust(d = col_dist, method = "ward.D2")
col_order <- c(col_order, colnames(temp_mat)[col_clust$order])
} else if(length(samples) == 1){
col_order <- c(col_order, samples)
} else{}
}
} else if (col_cluster_by == "all") {
col_dist  <- stats::dist(x = t(expr_mat_scaled), method = "euclidean")
col_clust <- stats::hclust(d = col_dist, method = "ward.D2")
col_order <- colnames(expr_mat_scaled)[col_clust$order]
} else if (col_cluster_by == "alphabetical"){
col_order <- sort(colnames(expr_mat_scaled))
} else {
col_order <- colnames(expr_mat_scaled)
}
# Logical ordering for rows (Genes)
if (row_cluster_by %in% colnames(row_annotation)) {
# Initialize column order
row_order <- c()
# Identify all groups
row_vars <- row_annotation %>%
dplyr::pull(row_cluster_by) %>%
unique() %>%
sort()  # While calculating gaps_row, we used count() which sorts
# alphabetically. So, WE MUST sort row_vars to match gaps_row
# Iterate over each group
for (row_var in row_vars){
# Get genes belonging to this group
genes <- row_annotation %>%
tibble::rownames_to_column("SYMBOL") %>%
dplyr::filter(.data[[row_cluster_by]] == row_var) %>%
dplyr::pull(SYMBOL) %>%
base::intersect(., rownames(expr_mat_scaled))
if (length(genes) > 1){
# Hierarchical clustering within cluster
temp_mat  <- expr_mat_scaled[genes, , drop = FALSE]
row_dist  <- stats::dist(x = temp_mat, method = "euclidean")
row_clust <- stats::hclust(d = row_dist, method = "ward.D2")
row_order <- c(row_order, rownames(temp_mat)[row_clust$order])
} else if(length(genes) == 1){
row_order <- c(row_order, genes)
} else{}
}
} else if (row_cluster_by == "all") {
row_dist  <- stats::dist(x = expr_mat_scaled, method = "euclidean")
row_clust <- stats::hclust(d = row_dist, method = "ward.D2")
row_order <- rownames(expr_mat_scaled)[row_clust$order]
} else if (row_cluster_by == "alphabetical"){
row_order <- sort(rownames(expr_mat_scaled))
} else {
row_order <- rownames(expr_mat_scaled) # Default to input order
}
# Final order of rows and columns
reordered <- expr_mat_scaled[row_order, col_order]
# ---- ðŸŽ¨ Heatmap Aesthetics ----
# For text to be readable, ideal fontsize = 10 points.
# For plot to be pretty, ideal cell_width and cell_height = fontsize + 5 points
# In 8.5 x 11 inch page, ideal plot area ~ 6 x 8 inch (excluding figure legend,
# column/row annotations, plot margins). So, plot area ~ 6*72 points wide and
# 8*72 points high.
# NOTE: If you use col_gaps, then heatmap can get cutoff. In such cases,
# increase page width of pdf from 8inch to 10inch in  ---- ðŸ’¾ Save Plots
# Set font sizes
fontsize <- 10
fontsize_number <- fontsize * 0.8
angle_col <- 45                           # column label angle
# Set cell width, height (in points) dynamically
cell_width <- min(fontsize + 5, (6 * 72) / ncol(reordered))
cell_height <- min(fontsize + 5, (8 * 72) / nrow(reordered))
# Truncate long plot title
# NOTE: pheatmap() throws error if plot_title = NULL
plot_title <- if(!is.null(plot_title)) {
stringr::str_wrap(string = plot_title, width = 20)
} else { NA }
# Truncate long row labels and display ONLY is cell_height is sufficient
labels_row <- if (!is.null(label_genes)){
dplyr::if_else(condition = rownames(reordered) %in% make.names(label_genes),
true = stringr::str_trunc(string = rownames(reordered), width = 15),
false = " ")
} else if (cell_height == fontsize + 5) {
stringr::str_trunc(string = rownames(reordered), width = 15)
} else {
rep(x = " ", times = nrow(reordered))
}
# Truncate long column labels and display ONLY is cell_width is sufficient
labels_col <- if (cell_width == fontsize + 5) {
stringr::str_trunc(string = colnames(reordered), width = 15)
} else{
rep(x = " ", times = ncol(reordered))
}
# ---- ðŸ–¼ï¸ Generate Heatmap Plot ----
ph <- pheatmap::pheatmap(mat               = reordered,
color             = heatmap_palette,
breaks            = breaks,
annotation_row    = row_annotation,
annotation_col    = col_annotation,
annotation_colors = ann_colors,
gaps_row          = gaps_row,
gaps_col          = gaps_col,
cellwidth         = cell_width,
cellheight        = cell_height,
show_rownames     = cell_height >= fontsize,
show_colnames     = cell_width >= fontsize,
labels_row        = labels_row,
labels_col        = labels_col,
angle_col         = angle_col,        # column label angle
fontsize          = fontsize,         # points; 72 points = 1 inch
fontsize_row      = fontsize,         # points
fontsize_col      = fontsize,         # points
fontsize_number   = fontsize_number,  # points
silent            = TRUE,
main              = plot_title,
border_color      = border_color,
legend            = show_expr_legend,
scale                    = "none",
cluster_rows             = FALSE,
cluster_cols             = FALSE,
# clustering_distance_rows = "correlation", #"euclidean",
# clustering_distance_cols = "correlation", #"euclidean",
# clustering_method        = "average",     #"ward.D2",
annotation_legend        = TRUE,
annotation_names_row     = FALSE,
annotation_names_col     = FALSE,
width                    = NA,               # inches
height                   = NA,               # inches
filename                 = NA)
# Prepare matrix for saving in excel
ph_mat <- reordered
# Excel maximum limits
max_rows <- 1e6
max_cols <- 16384
# Transpose if needed to fit in Excel
if(ncol(reordered) > max_cols && ncol(reordered) <= max_rows && nrow(reordered) <= max_cols){
ph_mat <- t(reordered)
} else if(nrow(reordered) > max_rows){
warning("Matrix is too large for Excel even after transpose. Consider saving as CSV or binary format.")
}
# ---- ðŸ’¾ Save Plots ----
if (save_plot){
file_extension <- ".pdf"
file_name <- file.path(output_dir,
paste0("Heatmap_Plot_", filename, file_extension))
# Open multi-page PDF
grDevices::cairo_pdf(filename = file_name, width = 10, height = 11.5, onefile = TRUE)
# Page 1
grid::grid.draw(x = ph$gtable)
grDevices::dev.off()
}
if (save_matrix){
file_extension <- ".xlsx"
file_name <- file.path(output_dir,
paste0("Heatmap_Matrix_", filename, file_extension))
wb <- openxlsx::createWorkbook()
openxlsx::addWorksheet(wb, sheetName = "Heatmap_matrix")
openxlsx::writeData(wb, sheet = "Heatmap_matrix", x = ph_mat, rowNames = TRUE)
openxlsx::saveWorkbook(wb, file = file_name, overwrite = TRUE)
}
# ---- ðŸªµ Log Output and Return ----
log_info(sample = "",
step   = "plot_heatmap",
msg    = glue::glue("Generated heatmap with {nrow(reordered)} genes and {ncol(reordered)} samples."))
return(invisible(list(ph = ph, mat = ph_mat)))
}
ph <- plot_heatmap(expr_mat            = mat,
filename            = "Xinyi",
output_dir          = proj_dir,
metadata_col        = metadata_col,
metadata_row        = metadata_row,
col_annotations     = c("consensusClass"),
row_annotations     = c("Category"),
col_gap_by          = c("consensusClass"),
row_gap_by          = c("Category"),
col_cluster_by      = c("consensusClass"),
row_cluster_by      = c("Category"),
plot_title          = NULL,
heatmap_palette     = "rdbu",
annotation_palette  = "discrete",
border_color        = NA,
force_log           = FALSE,
show_expr_legend    = TRUE,
save_plot           = TRUE,
save_matrix         = TRUE)
ph <- plot_heatmap(expr_mat            = mat,
filename            = "Xinyi",
output_dir          = proj_dir,
metadata_col        = metadata_col,
metadata_row        = metadata_row,
col_annotations     = c("consensusClass"),
row_annotations     = c("Category"),
col_gap_by          = c("consensusClass"),
row_gap_by          = c("Category"),
col_cluster_by      = c("consensusClass"),
row_cluster_by      = c("Category"),
plot_title          = NULL,
heatmap_palette     = "rdbu",
annotation_palette  = "discrete",
border_color        = NA,
force_log           = FALSE,
show_expr_legend    = TRUE,
save_plot           = TRUE,
save_matrix         = TRUE)
View(metadata_col)
metadata_col <- dplyr::left_join(x = metadata %>% dplyr::mutate(Sample_ID = make.names(Sample_ID)),
y = cl %>% tibble::rownames_to_column("Sample_ID"),
by = c("Sample_ID" = "Sample_ID")) %>%
dplyr::filter(Condition != "Normal")
View(metadata_col)
# Save the results
wb <- openxlsx::createWorkbook()
openxlsx::addWorksheet(wb, sheetName = "Classification")
openxlsx::writeData(wb, sheet = "Classification", x = metadata_col)
openxlsx::saveWorkbook(wb, file = file.path(proj_dir,"Classification.xlsx"), overwrite = TRUE)
wb <- openxlsx::createWorkbook()
openxlsx::addWorksheet(wb, sheetName = "VST counts")
openxlsx::writeData(wb, sheet = "VST counts", x = vsd_batch_corrected)
openxlsx::saveWorkbook(wb, file = file.path(proj_dir,"Batch corrected VST counts.xlsx"), overwrite = TRUE)
ph <- plot_heatmap(expr_mat            = mat,
label_genes         =  metadata_row$SYMBOL,
filename            = "Xinyi",
output_dir          = proj_dir,
metadata_col        = metadata_col,
metadata_row        = metadata_row,
col_annotations     = c("consensusClass"),
row_annotations     = c("Category"),
col_gap_by          = c("consensusClass"),
row_gap_by          = c("Category"),
col_cluster_by      = c("consensusClass"),
row_cluster_by      = c("Category"),
plot_title          = NULL,
heatmap_palette     = "rdbu",
annotation_palette  = "discrete",
border_color        = NA,
force_log           = FALSE,
show_expr_legend    = TRUE,
save_plot           = TRUE,
save_matrix         = TRUE)
