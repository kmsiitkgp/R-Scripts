contrasts     = contrasts ,               # Vector of contrasts for DE analysis
design        = "Comparisons",            # DESeq2 design formula or column name
#lfc_cutoff    = 0,                        # Log fold change cutoff for significance
#padj_cutoff   = 0.1,                      # Adjusted p-value cutoff for significance
batch_correct = FALSE                     # Boolean, whether to apply batch correction
)
# Heatmap overrides
heatmap.override <- list(
col_annotations    = c("Condition", "Treatment"),        # NULL, 1 or more columns from metadata_col for column annotation
#row_annotations    = NULL,        # NULL, 1 or more columns from metadata_row for row annotation
#col_gap_by         = NULL,        # NULL, 1 column from metadata_col to define column gaps in heatmap
#row_gap_by         = NULL,        # NULL, 1 column from metadata_row to define row gaps in heatmap
col_cluster_by     = "allx",       # NULL, 1 column from metadata_col, "all", "alphabetical" for clustering columns
row_cluster_by     = "all",       # NULL, 1 column from metadata_row, "all", "alphabetical" for clustering columns
#plot_title         = NULL,        # NULL, Title for heatmap (default NULL i.e. no title)
#heatmap_palette    = "rdbu",      # Color palette for heatmap matrix ("rdbu" or "vrds")
#annotation_palette = "discrete",  # Color palette for heatmap annotation ("discrete" or "continuous")
#border_color       = NA,          # Color of heatmap cell borders (default NA i.e. no border)
#force_log          = FALSE,       # Force log transform (default FALSE i.e. auto detect)
#show_expr_legend   = TRUE,        # Show expression legend (set FALSE if annotations overlap)
save_plot          = TRUE,       # Save the heatmap plot as pdf (default FALSE i.e. no save)
save_matrix        = TRUE        # Save the heatmap matrix as xlsx (default FALSE i.e. no save)
)
# Volcano plot overrides
volcano.override <- list(
#top_n        = 5,                  # If label_genes = NULL, label top_n genes (default 5 genes)
#lfc_cutoff   = 0.58,               # Log fold change cutoff (default 0.58)
padj_cutoff  = 0.05                # Adjusted p-value cutoff (default 0.05)
)
proj.params <- setup_project(proj             = proj,
species          = species,  #"Mus musculus", "Homo sapiens"
contrasts        = contrasts,
parent_dir       = parent_dir,
gmt_dir          = gmt_dir,
scripts_dir      = scripts_dir,
deseq2.override  = deseq2.override,
heatmap.override = heatmap.override,
volcano.override = volcano.override)
# ---- Fetch Annotations ONCE at the start ----
ann_list <- get_annotations()
# ---- üßæ Load Metadata ----
metadata_xlsx <- file.path(proj.params$proj_dir, paste0(proj, "_Metadata.xlsx"))
metadata <- openxlsx::read.xlsx(xlsxFile = metadata_xlsx)
# ---- üì• Load raw counts ----
proj_name       <- proj.params$proj
proj_dir        <- proj.params$proj_dir
counts_dir      <- proj.params$counts_dir
raw_counts_xlsx <- file.path(proj.params$proj_dir, paste0(proj, "_Raw_counts.xlsx"))
if (dir.exists(counts_dir) && length(list.files(counts_dir)) > 0){
# Compile raw counts from  txt files
raw_counts_mat <- merge_counts(counts_dir = counts_dir,
filename   = proj_name,
output_dir = proj_dir)
} else if (file.exists(raw_counts_xlsx)){
# Read raw counts from excel file
raw_counts_df <- openxlsx::read.xlsx(xlsxFile = raw_counts_xlsx)
if (!"SYMBOL" %in% colnames(raw_counts_df)) {
log_warn(sample = "",
step   = "RNASeq_Workflow.R",
msg    = "1st column of xlsx file should be named 'SYMBOL'")
} else {
raw_counts_mat <- raw_counts_df %>%
tibble::column_to_rownames("SYMBOL")
}
} else {
log_error(sample = "",
step = "RNASeq_Workflow.R",
msg = glue::glue("Please provide raw counts in excel file '{raw_counts_xlsx}' or as txt files in '{counts_dir}'"))
}
# ---- üõ†Ô∏è Prepare DESeq2 Input ----
design      <- proj.params$deseq2$design
deseq2_data <- prepare_deseq2_input(expr_mat = raw_counts_mat,
metadata = metadata,
design   = design)
# ---- üîç QC : Initial PCA & Batch Inspection ----
proj_name <- proj.params$proj
proj_dir  <- proj.params$proj_dir
plot_pca(expr_mat    = deseq2_data$expr_mat,
metadata    = deseq2_data$metadata,
filename    = proj_name,
output_dir  = proj_dir,
top_n_genes = 500,
perform_vst = TRUE,
skip_plot   = FALSE)
# ---- üßπ Sample Filtering : Outlier Removal ----
remove_samples <- NULL
# remove_samples <- c("SBQuadFc2", "SBQuadFc4")
if (!is.null(remove_samples)){
raw_counts_mat <- raw_counts_mat[, !(colnames(raw_counts_mat) %in% remove_samples), drop = FALSE]
# ---- üõ†Ô∏è Prepare DESeq2 Input ----
design      <- proj.params$deseq2$design
deseq2_data <- prepare_deseq2_input(expr_mat = raw_counts_mat,
metadata = metadata,
design   = design)
}
# ---- üß¨ Differential Expression (DESeq2 model) ----
dds <- fit_deseq2_model(expr_mat    = deseq2_data$expr_mat,
metadata    = deseq2_data$metadata,
design      = design)
# Extract non-blind VST Counts (for all downstream visualization)
vsd <- DESeq2::vst(dds, blind = FALSE)
vst_counts <- SummarizedExperiment::assay(vsd) %>%
as.data.frame() %>%
tibble::rownames_to_column("ID") %>%
add_annotation(ann_list = ann_list) %>%
dplyr::group_by(SYMBOL) %>%
dplyr::summarize(across(.cols = where(is.numeric), .fns = mean, na.rm = TRUE), .groups = "drop") %>%
tibble::column_to_rownames("SYMBOL") %>%
as.matrix()
# Extract blind VST Counts (for global heatmap ONLY)
# NOTE: vst counts are affected by design ONLY when blind=FALSE
vsd_blind <- DESeq2::vst(object = dds, blind  = TRUE)
vst_counts_blind <- SummarizedExperiment::assay(vsd_blind) %>%
as.data.frame() %>%
tibble::rownames_to_column("ID") %>%
add_annotation(ann_list = ann_list) %>%
dplyr::group_by(SYMBOL) %>%
dplyr::summarize(across(.cols = where(is.numeric), .fns = mean, na.rm = TRUE), .groups = "drop") %>%
tibble::column_to_rownames("SYMBOL") %>%
as.matrix()
# Extract normalized Counts (for violin/box plot of gene expression ONLY)
norm_counts <- DESeq2::counts(dds, normalized = TRUE) %>%
as.data.frame() %>%
tibble::rownames_to_column("ID") %>%
add_annotation(ann_list = ann_list) %>%
dplyr::group_by(SYMBOL) %>%
dplyr::summarize(across(.cols = where(is.numeric), .fns = mean, na.rm = TRUE), .groups = "drop") %>%
tibble::column_to_rownames("SYMBOL") %>%
as.matrix()
# ==== üåê GLOBAL QUALITY & EXPLORATION ====
# ---- üìâ QC : Dispersion Estimates ----
plot_dispersion(dds        = dds,
filename   = proj_name,
output_dir = proj_dir)
# ---- üî• Visualization : Heatmap (Global) ----
# Perform LRT
# 'reduced = ~1' tests if the 'design(dds)' significantly improves the model over no groups at all
dds_LRT <- DESeq2::DESeq(dds, test = "LRT", reduced = ~1)
res_LRT <- DESeq2::results(dds_LRT) %>%
as.data.frame() %>%
tibble::rownames_to_column("ID") %>%
add_annotation(ann_list = ann_list)
# Identify significant DEGs
sig_genes <- res_LRT %>%
dplyr::filter(padj <= 0.05) %>%
dplyr::pull(SYMBOL) %>%
base::intersect(rownames(vst_counts_blind))
# Plot heatmap
ph <- plot_heatmap(expr_mat            = vst_counts_blind[sig_genes, , drop = FALSE],
label_genes         = NULL,
filename            = proj_name,
output_dir          = proj_dir,
metadata_col        = metadata,
metadata_row        = NULL,
col_annotations     = proj.params$heatmap$col_annotations,
row_annotations     = proj.params$heatmap$row_annotations,
col_gap_by          = proj.params$heatmap$col_gap_by,
row_gap_by          = proj.params$heatmap$row_gap_by,
col_cluster_by      = proj.params$heatmap$col_cluster_by,
row_cluster_by      = proj.params$heatmap$row_cluster_by,
plot_title          = proj.params$heatmap$plot_title,
heatmap_palette     = proj.params$heatmap$heatmap_palette,
annotation_palette  = proj.params$heatmap$annotation_palette,
border_color        = proj.params$heatmap$border_color,
force_log           = proj.params$heatmap$force_log,
show_expr_legend    = proj.params$heatmap$show_expr_legend,
save_plot           = proj.params$heatmap$save_plot,
save_matrix         = proj.params$heatmap$save_matrix)
# ==== üîÅ DIFFERENTIAL EXPRESSION PER CONTRAST ====
species   <- proj.params$species
contrasts <- proj.params$deseq2$contrasts
proj_dir  <- proj.params$proj_dir
gmt_dir   <- proj.params$gmt_dir
for (contrast in contrasts) {
log_info(sample = contrast,
step   = "RNASeq_Workflow.R",
msg    = glue::glue("Extracting DESeq2 results for contrast: '{contrast}'"))
# Identify samples for current contrast
contrast_samples <- metadata %>%
dplyr::filter(Comparisons %in% all.vars(expr = as.formula(paste0("~", contrast)))) %>%
dplyr::pull(Sample_ID) %>%
as.character()
# ---- üß¨ Differential Expression (DESeq2 results) ----
contrast_dir <- file.path(proj_dir, contrast)
deseq2_results <- get_deseq2_results(dds         = dds,
contrast    = contrast,
output_dir  = contrast_dir,
lfc_cutoff  = 0,
padj_cutoff = 0.1)
# ---- üèπ Visualization : MA Plot ----
plot_ma(dds        = deseq2_results$dds,  # results() MUST be called on dds earlier
filename   = paste(proj_name, contrast, sep = "_"),
output_dir = contrast_dir)
# ---- üåã Visualization : Volcano Plot ----
plot_volcano(res_df      = deseq2_results$degs,
filename    = paste(proj_name, contrast, sep = "_"),
output_dir  = contrast_dir,
contrast    = contrast,
label_genes = proj.params$volcano$label_genes,
top_n       = proj.params$volcano$top_n,
lfc_cutoff  = proj.params$volcano$lfc_cutoff,
padj_cutoff = proj.params$volcano$padj_cutoff)
# ---- üî• Visualization : Heatmap ----
# Keep only samples present in vst
common_samples <- base::intersect(contrast_samples, colnames(vst_counts))
# Identify significant DEGs
sig_genes <- deseq2_results$degs %>%
dplyr::filter(padj <= 0.05) %>%
dplyr::pull(SYMBOL) %>%
base::intersect(rownames(vst_counts))
# Plot heatmap
ph <- plot_heatmap(expr_mat            = vst_counts[sig_genes, common_samples],
label_genes         = NULL,
filename            = paste(contrast, proj_name, sep = "_"),
output_dir          = contrast_dir,
metadata_col        = metadata,
metadata_row        = NULL,
col_annotations     = proj.params$heatmap$col_annotations,
row_annotations     = proj.params$heatmap$row_annotations,
col_gap_by          = proj.params$heatmap$col_gap_by,
row_gap_by          = proj.params$heatmap$row_gap_by,
col_cluster_by      = proj.params$heatmap$col_cluster_by,
row_cluster_by      = proj.params$heatmap$row_cluster_by,
plot_title          = proj.params$heatmap$plot_title,
heatmap_palette     = proj.params$heatmap$heatmap_palette,
annotation_palette  = proj.params$heatmap$annotation_palette,
border_color        = proj.params$heatmap$border_color,
force_log           = proj.params$heatmap$force_log,
show_expr_legend    = proj.params$heatmap$show_expr_legend,
save_plot           = proj.params$heatmap$save_plot,
save_matrix         = proj.params$heatmap$save_matrix)
# ---- üõ§Ô∏è Pathway Analysis (GSEA & ORA) ----
pathway_dir <- file.path(proj_dir, contrast, "Pathway_Analysis")
pathway_results <- analyze_pathway(res_df     = deseq2_results$degs,
species    = species,
gmt_dir    = gmt_dir,
output_dir = pathway_dir,
minsize    = 15,
maxsize    = 500)
# ---- üåø Visualization : Pathway Enrichment ----
# Identify top 10 Up & top 10 Down GSEA pathways for each collection
top_gsea <- pathway_results$consensus %>%
dplyr::filter(method != "ORA") %>%
# Deduplicate by method priority
dplyr::group_by(Collection, Consensus, Description) %>%
dplyr::slice_min(order_by = match(method, c("FGSEA", "GSEA", "ORA")), n = 1) %>%
dplyr::ungroup() %>%
# Rank based on abs(NES) for each direction
dplyr::group_by(Collection, Consensus) %>%
dplyr::slice_max(order_by = abs(NES), n = 10, with_ties = FALSE) %>%
dplyr::ungroup()
# Identify top 10 Up & top 10 Down ORA pathways for each collection
top_ora <- pathway_results$consensus %>%
dplyr::filter(method == "ORA") %>%
# Rank based on padj for each direction
dplyr::group_by(Collection, Consensus) %>%
dplyr::slice_min(order_by = padj, n = 10, with_ties = FALSE) %>%
dplyr::ungroup()
# Keep only samples present in vst
common_samples <- base::intersect(contrast_samples, colnames(vst_counts))
plot_pathway(pathway_df = top_gsea,
method     = "GSEA",
expr_mat   = vst_counts[, common_samples],
metadata   = metadata,
output_dir = pathway_dir)
plot_pathway(pathway_df = top_ora,
method     = "ORA",
expr_mat   = vst_counts[, common_samples],
metadata   = metadata,
output_dir = pathway_dir)
# ---- üì° Regulatory Network Analysis ----
# Keep only samples present in vst
common_samples <- base::intersect(contrast_samples, colnames(vst_counts))
tf_dir <- file.path(proj_dir, contrast, "TF_Analysis")
tf_activity_samples <- analyze_tf(expr_mat   = vst_counts[, common_samples],
res_df     = NULL,
species    = species,
output_dir = tf_dir,
stats      = c("ulm", "mlm", "viper"),
minsize    = 5,
top_n      = 500)
tf_activity_degs <- analyze_tf(expr_mat   = NULL,
res_df     = deseq2_results$degs,
species    = species,
output_dir = tf_dir,
stats      = c("ulm", "mlm", "viper"),
minsize    = 5,
top_n      = 500)
# ---- üåø Visualization : Regulatory Networks ----
plot_tf(tf_df      = tf_activity_samples$tf,
contrast   = contrast,
metadata   = metadata,
output_dir = tf_dir,
top_n      = 20)
plot_tf(tf_df      = tf_activity_degs$tf,
contrast   = contrast,
metadata   = metadata,
output_dir = tf_dir,
top_n      = 20)
}
gmt_dir
gmt_file
list.files(gmt_dir)
proj.params <- setup_project(proj             = proj,
species          = species,  #"Mus musculus", "Homo sapiens"
contrasts        = contrasts,
parent_dir       = parent_dir,
gmt_dir          = file.path(gmt_dir, species),
scripts_dir      = scripts_dir,
deseq2.override  = deseq2.override,
heatmap.override = heatmap.override,
volcano.override = volcano.override)
list.files(gmt_dir)
list.files(proj.params$gmt_dir)
gmt_dir
gmt_dir
proj.params$gmt_dir
gmt_dir   <- proj.params$gmt_dir
for (contrast in contrasts) {
log_info(sample = contrast,
step   = "RNASeq_Workflow.R",
msg    = glue::glue("Extracting DESeq2 results for contrast: '{contrast}'"))
# Identify samples for current contrast
contrast_samples <- metadata %>%
dplyr::filter(Comparisons %in% all.vars(expr = as.formula(paste0("~", contrast)))) %>%
dplyr::pull(Sample_ID) %>%
as.character()
# ---- üß¨ Differential Expression (DESeq2 results) ----
contrast_dir <- file.path(proj_dir, contrast)
deseq2_results <- get_deseq2_results(dds         = dds,
contrast    = contrast,
output_dir  = contrast_dir,
lfc_cutoff  = 0,
padj_cutoff = 0.1)
# ---- üèπ Visualization : MA Plot ----
plot_ma(dds        = deseq2_results$dds,  # results() MUST be called on dds earlier
filename   = paste(proj_name, contrast, sep = "_"),
output_dir = contrast_dir)
# ---- üåã Visualization : Volcano Plot ----
plot_volcano(res_df      = deseq2_results$degs,
filename    = paste(proj_name, contrast, sep = "_"),
output_dir  = contrast_dir,
contrast    = contrast,
label_genes = proj.params$volcano$label_genes,
top_n       = proj.params$volcano$top_n,
lfc_cutoff  = proj.params$volcano$lfc_cutoff,
padj_cutoff = proj.params$volcano$padj_cutoff)
# ---- üî• Visualization : Heatmap ----
# Keep only samples present in vst
common_samples <- base::intersect(contrast_samples, colnames(vst_counts))
# Identify significant DEGs
sig_genes <- deseq2_results$degs %>%
dplyr::filter(padj <= 0.05) %>%
dplyr::pull(SYMBOL) %>%
base::intersect(rownames(vst_counts))
# Plot heatmap
ph <- plot_heatmap(expr_mat            = vst_counts[sig_genes, common_samples],
label_genes         = NULL,
filename            = paste(contrast, proj_name, sep = "_"),
output_dir          = contrast_dir,
metadata_col        = metadata,
metadata_row        = NULL,
col_annotations     = proj.params$heatmap$col_annotations,
row_annotations     = proj.params$heatmap$row_annotations,
col_gap_by          = proj.params$heatmap$col_gap_by,
row_gap_by          = proj.params$heatmap$row_gap_by,
col_cluster_by      = proj.params$heatmap$col_cluster_by,
row_cluster_by      = proj.params$heatmap$row_cluster_by,
plot_title          = proj.params$heatmap$plot_title,
heatmap_palette     = proj.params$heatmap$heatmap_palette,
annotation_palette  = proj.params$heatmap$annotation_palette,
border_color        = proj.params$heatmap$border_color,
force_log           = proj.params$heatmap$force_log,
show_expr_legend    = proj.params$heatmap$show_expr_legend,
save_plot           = proj.params$heatmap$save_plot,
save_matrix         = proj.params$heatmap$save_matrix)
# ---- üõ§Ô∏è Pathway Analysis (GSEA & ORA) ----
pathway_dir <- file.path(proj_dir, contrast, "Pathway_Analysis")
pathway_results <- analyze_pathway(res_df     = deseq2_results$degs,
species    = species,
gmt_dir    = gmt_dir,
output_dir = pathway_dir,
minsize    = 15,
maxsize    = 500)
# ---- üåø Visualization : Pathway Enrichment ----
# Identify top 10 Up & top 10 Down GSEA pathways for each collection
top_gsea <- pathway_results$consensus %>%
dplyr::filter(method != "ORA") %>%
# Deduplicate by method priority
dplyr::group_by(Collection, Consensus, Description) %>%
dplyr::slice_min(order_by = match(method, c("FGSEA", "GSEA", "ORA")), n = 1) %>%
dplyr::ungroup() %>%
# Rank based on abs(NES) for each direction
dplyr::group_by(Collection, Consensus) %>%
dplyr::slice_max(order_by = abs(NES), n = 10, with_ties = FALSE) %>%
dplyr::ungroup()
# Identify top 10 Up & top 10 Down ORA pathways for each collection
top_ora <- pathway_results$consensus %>%
dplyr::filter(method == "ORA") %>%
# Rank based on padj for each direction
dplyr::group_by(Collection, Consensus) %>%
dplyr::slice_min(order_by = padj, n = 10, with_ties = FALSE) %>%
dplyr::ungroup()
# Keep only samples present in vst
common_samples <- base::intersect(contrast_samples, colnames(vst_counts))
plot_pathway(pathway_df = top_gsea,
method     = "GSEA",
expr_mat   = vst_counts[, common_samples],
metadata   = metadata,
output_dir = pathway_dir)
plot_pathway(pathway_df = top_ora,
method     = "ORA",
expr_mat   = vst_counts[, common_samples],
metadata   = metadata,
output_dir = pathway_dir)
# ---- üì° Regulatory Network Analysis ----
# Keep only samples present in vst
common_samples <- base::intersect(contrast_samples, colnames(vst_counts))
tf_dir <- file.path(proj_dir, contrast, "TF_Analysis")
tf_activity_samples <- analyze_tf(expr_mat   = vst_counts[, common_samples],
res_df     = NULL,
species    = species,
output_dir = tf_dir,
stats      = c("ulm", "mlm", "viper"),
minsize    = 5,
top_n      = 500)
tf_activity_degs <- analyze_tf(expr_mat   = NULL,
res_df     = deseq2_results$degs,
species    = species,
output_dir = tf_dir,
stats      = c("ulm", "mlm", "viper"),
minsize    = 5,
top_n      = 500)
# ---- üåø Visualization : Regulatory Networks ----
plot_tf(tf_df      = tf_activity_samples$tf,
contrast   = contrast,
metadata   = metadata,
output_dir = tf_dir,
top_n      = 20)
plot_tf(tf_df      = tf_activity_degs$tf,
contrast   = contrast,
metadata   = metadata,
output_dir = tf_dir,
top_n      = 20)
}
#!/usr/bin/env Rscript
# Read and store variables from command line interface (CLI)
cli <- base::commandArgs(trailingOnly = TRUE)
args <- base::strsplit(x = cli, split = "=", fixed = TRUE)
for (e in args){
argname <- e[1]
argval <- e[2]
assign(argname, argval)
}
# ==== üß¨ BULK RNA-SEQ WORKFLOW ====
# ---- ‚öôÔ∏èÔ∏è Project Setup ----
if (.Platform$OS.type == "windows") {
parent_dir  <- "C:/Users/kailasamms/OneDrive - Cedars-Sinai Health System/Desktop/Collaboration projects data"
gmt_dir     <- "C:/Users/kailasamms/OneDrive - Cedars-Sinai Health System/Documents/GSEA_genesets"
scripts_dir <- NULL
script_file <- "C:/Users/kailasamms/OneDrive - Cedars-Sinai Health System/Documents/GitHub/R-Scripts/Custom_Functions.R"
} else {  # Linux/macOS (e.g., HPC)
parent_dir  <- "/hpc/home/kailasamms/scratch"
gmt_dir     <- "/hpc/home/kailasamms/projects/GSEA_genesets"
scripts_dir <- "/hpc/home/kailasamms/projects/scRNASeq"
script_file <- "/hpc/home/kailasamms/projects/scRNASeq/Custom_Functions.R"
}
if (file.exists(script_file)) {
source(script_file)
} else{
stop(paste("Custom_Functions.R not found at:", script_file))
}
# Define these 4 variables in project specific script
# contrasts <- c()
# deseq2.override <- list()
# heatmap.override <- list()
# volcano.override <- list()
proj <- "GSE132408"
species <- "Homo sapiens"
contrasts <- c("TET2KO-WT",
"TET2KO.IFNy-WT.IFNy")
# DESeq2 overrides
deseq2.override <- list(
contrasts     = contrasts ,               # Vector of contrasts for DE analysis
design        = "Comparisons",            # DESeq2 design formula or column name
#lfc_cutoff    = 0,                        # Log fold change cutoff for significance
#padj_cutoff   = 0.1,                      # Adjusted p-value cutoff for significance
batch_correct = FALSE                     # Boolean, whether to apply batch correction
)
# Heatmap overrides
heatmap.override <- list(
col_annotations    = c("Condition", "Treatment"),        # NULL, 1 or more columns from metadata_col for column annotation
#row_annotations    = NULL,        # NULL, 1 or more columns from metadata_row for row annotation
#col_gap_by         = NULL,        # NULL, 1 column from metadata_col to define column gaps in heatmap
#row_gap_by         = NULL,        # NULL, 1 column from metadata_row to define row gaps in heatmap
col_cluster_by     = "allx",       # NULL, 1 column from metadata_col, "all", "alphabetical" for clustering columns
row_cluster_by     = "all",       # NULL, 1 column from metadata_row, "all", "alphabetical" for clustering columns
#plot_title         = NULL,        # NULL, Title for heatmap (default NULL i.e. no title)
#heatmap_palette    = "rdbu",      # Color palette for heatmap matrix ("rdbu" or "vrds")
#annotation_palette = "discrete",  # Color palette for heatmap annotation ("discrete" or "continuous")
#border_color       = NA,          # Color of heatmap cell borders (default NA i.e. no border)
#force_log          = FALSE,       # Force log transform (default FALSE i.e. auto detect)
#show_expr_legend   = TRUE,        # Show expression legend (set FALSE if annotations overlap)
save_plot          = TRUE,       # Save the heatmap plot as pdf (default FALSE i.e. no save)
save_matrix        = TRUE        # Save the heatmap matrix as xlsx (default FALSE i.e. no save)
)
# Volcano plot overrides
volcano.override <- list(
#top_n        = 5,                  # If label_genes = NULL, label top_n genes (default 5 genes)
#lfc_cutoff   = 0.58,               # Log fold change cutoff (default 0.58)
padj_cutoff  = 0.05                # Adjusted p-value cutoff (default 0.05)
)
